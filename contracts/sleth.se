data current_round
data last_processed_block
data last_processed_round

data rounds[2^160](player, block, timestamp, bet, result, entropy, status)
data players[2^160](last_round, balance)

# status:
# 0 = new
# 1 = spinning
# 2 = done

def shared():
    MIN_BET = 1
    MAX_BET = 5

    REEL_COUNT = 3
    REEL_POSITIONS = 32
    ROW_COUNT = 3

# funid=0
def spin(bet):

    if bet < MIN_BET or bet > MAX_BET:
        return(0)  # bet out of range

    if bet > self.players[msg.sender].balance:
        return(0)  # insufficient funds

    self.players[msg.sender].balance -= bet

    current_round = self.current_round
    self.rounds[current_round].player = msg.sender
    self.rounds[current_round].block = block.number
    self.rounds[current_round].timestamp = block.timestamp
    self.rounds[current_round].bet = bet
    self.rounds[current_round].status = 1
    self.players[msg.sender].last_round = current_round
    self.current_round = current_round + 1
    return(1)

# funid=1
def claim(round):
    if block.number > self.last_processed_block:
        round = self.last_processed_round
        current_round = self.current_round
        while round < current_round:
            # TODO stuff
            round += 1

        self.last_processed_block = block.number
        self.last_processed_round = round
        return(1)
    else:
        return(0)

# funid=2
def deposit():
    self.players[msg.sender].balance += msg.value
    return(1)

# funid=3
def withdraw(amount):
    if amount <= self.players[msg.sender].balance:
        self.players[msg.sender].balance -= amount
        send(msg.sender, amount)
        return(1)
    return(0)

# funid=4
def get_round(round):
    return([self.rounds[round].player, self.rounds[round].block, self.rounds[round].timestamp, self.rounds[round].bet, self.rounds[round].result, self.rounds[round].entropy, self.rounds[round].status], 7)

# funid=5
def get_current_player():
    return([self.players[msg.sender].last_round, self.players[msg.sender].balance], 2)

def calc_line(s1, s2, s3):
    match_payout = array(11)
    match_payout[7] = 4  # 3Down
    match_payout[6] = 6  # 2Down
    match_payout[5] = 8  # 1Down
    match_payout[1] = 10  # 1Up
    match_payout[2] = 15  # 2Up
    match_payout[3] = 20  # 3Up
    match_payout[4] = 25  # OrangeRed
    match_payout[0] = 50  # AlienHead
    match_payout[9] = 75  # Bacon
    match_payout[10] = 100  # Narwhal
    match_payout[8] = 250  # CakeDay

    payout_ups = 6  # Any 3 Ups
    payout_downs = 2  # Any 3 Downs

    # perfect match
    if s1 == s2 and s2 == s3:
        return(match_payout[s1])

    # special case #1: triple ups
    if ((s1 == 1 or s1 == 2 or s1 == 3) and (s2 == 1 or s2 == 2 or s2 == 3) and (s3 == 1 or s3 == 2 or s3 == 3)):
        return payout_ups

    # special case #2: triple down
    if ((s1 == 5 or s1 == 6 or s1 == 7) and (s2 == 5 or s2 == 6 or s2 == 7) and (s3 == 5 or s3 == 6 or s3 == 7)):
        return payout_downs

    # special case #3: bacon goes with everything
    if s1 == 9:
        if s2 == s3:
            return match_payout[s2]

        # wildcard trip ups
        if ((s2 == 1 or s2 == 2 or s2 == 3) and (s3 == 1 or s3 == 2 or s3 == 3)):
            return payout_ups

        # wildcard trip downs
        if ((s2 == 5 or s2 == 6 or s2 == 7) and (s3 == 5 or s3 == 6 or s3 == 7)):
            return payout_downs

    if s2 == 9:
        if s1 == s3:
            return match_payout[s1]

        # wildcard trip ups
        if ((s1 == 1 or s1 == 2 or s1 == 3) and (s3 == 1 or s3 == 2 or s3 == 3)):
            return payout_ups

        # wildcard trip downs
        if ((s1 == 5 or s1 == 6 or s1 == 7) and (s3 == 5 or s3 == 6 or s3 == 7)):
            return payout_downs

    if s3 == 9:
        if s1 == s2:
            return match_payout[s1]

        # wildcard trip ups
        if ((s1 == 1 or s1 == 2 or s1 == 3) and (s2 == 1 or s2 == 2 or s2 == 3)):
            return payout_ups

        # wildcard trip downs
        if ((s1 == 5 or s1 == 6 or s1 == 7) and (s2 == 5 or s2 == 6 or s2 == 7)):
            return payout_downs

    # check double-bacon
    if s2 == 9 and s3 == 9:
        return match_payout[s1]
    if s1 == 9 and s3 == 9:
        return match_payout[s2]
    if s1 == 9 and s2 == 9:
        return match_payout[s3]

    # no reward
    return(0)

def get_stops(rnd):
    stops = array(REEL_COUNT)
    i = 0
    while i < REEL_COUNT:
        stops[i] = mod(rnd, REEL_POSITIONS)
        rnd = div(rnd, REEL_POSITIONS)
        i += 1
    return(stops, REEL_COUNT)

def calc_reward(rnd, playing_lines):
    result_0 = array(ROW_COUNT)
    result_1 = array(ROW_COUNT)
    result_2 = array(ROW_COUNT)

    reel_0 = [2,1,7,1,2,7,6,7,3,10,1,6,1,7,3,4,3,2,4,5,0,6,10,5,6,5,8,3,0,9,5,4]
    reel_1 = [6,0,10,3,6,7,9,2,5,2,3,1,5,2,1,10,4,5,8,4,7,6,0,1,7,6,3,1,5,9,7,4]
    reel_2 = [1,4,2,7,5,6,4,10,7,5,2,0,6,4,10,1,7,6,3,0,5,7,2,3,9,3,5,6,1,8,1,3]

    stops = self.get_stops(rnd, outsz=REEL_COUNT)
    i = 0
    while i < ROW_COUNT:
        result_0[i] = reel_0[stops[0] + i]
        result_1[i] = reel_1[stops[1] + i]
        result_2[i] = reel_2[stops[2] + i]
        i += 1

    # line 1
    payout = self.calc_line(result_0[1], result_1[1], result_2[1])

    if playing_lines > 1:
        # line 2
        payout += self.calc_line(result_0[0], result_1[0], result_2[0])
        # line 3
        payout += self.calc_line(result_0[2], result_1[2], result_2[2])

        if playing_lines > 3:
            # line 4
            payout += self.calc_line(result_0[0], result_1[1], result_2[2])
            # line 5
            payout += self.calc_line(result_0[2], result_1[1], result_2[0])

    return(payout)
