data ticket_count
data tickets[2^50](owner, status, target, random)
# random value for each ticket are a hashchain based on the random seed for a block

data blocks[2^50](status, seed, commit_count, reveal_count, commits[2^50](owner, hash, value), ticket_count, tickets[2^50](ticket_id))
# commits are per block
# reveal required to get deposit back

def shared():
    REVEAL_WINDOW = 2
    DEPOSIT = 2000

# returns: ticket_id, block eta
def request_entropy():
    target = block.number + 1

    # initialize ticket
    ticket_id = self.ticket_count
    self.tickets[ticket_id].owner = msg.sender
    self.tickets[ticket_id].target = target
    self.ticket_count = ticket_id + 1

    # add ticket to target block
    ticket_idx = self.blocks[target].ticket_count
    self.blocks[target].tickets[ticket_idx] = ticket_id
    self.blocks[target].ticket_count = ticket_idx + 1

    # return ticket_id and eta
    return([ticket_id, eta], 2)

# returns: status, entropy
# status = 0 pending
# status = 1 ready
# status = 2 expired
# status = 3 not yours / not found
def get_entropy(ticket_id):
    if msg.sender != self.tickets[ticket_id].owner:
        return([3, 0], 2)  # not yours / not found

    status = self.tickets[ticket_id].status
    if status == 1:
        return([1, self.tickets[ticket_id].random], 2)  # ready
    else:
        if block.number > self.tickets[ticket_id].target + REVEAL_WINDOW:
            return([2, 0], 2)  # expired
        else:
            return([0, 0], 2)  # pending


# XXX how many blocks in the future could you be allowed to commit to?
def commit(target, hash):
    if msg.value < DEPOSIT:
        return(0)  # insufficient deposit

    if target <= block.number:
        return(0)  # block no longer available

    # store hash on list
    commit_idx = self.blocks[target].commit_count
    self.blocks[target].commits[commit_idx].sender = msg.sender
    self.blocks[target].commits[commit_idx].hash = hash
    self.blocks[target].commit_count = commit_idx + 1

    return(1)

# XXX how to address subindex?
def reveal(target, value):
    # check hash(value) matches hash
    # store value
    # return deposit

    # if reveal_count == commit_count: calculate entropy
